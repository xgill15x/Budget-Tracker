{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","map":{"version":3,"sources":["C:/Users/jason/OneDrive/desktop/BudgetTracker/react/node_modules/@babel/traverse/lib/path/lib/hoister.js"],"names":["Object","defineProperty","exports","value","default","_t","require","_t2","react","cloneNode","jsxExpressionContainer","variableDeclaration","variableDeclarator","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","key","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","get","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","insertFn","attached","isVariableDeclarator","isJSXElement","children","replaceWith"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,EAAE,GAAGC,OAAO,CAAC,cAAD,CAAhB;;AAEA,IAAIC,GAAG,GAAGF,EAAV;AACA,MAAM;AACJG,EAAAA;AADI,IAEFH,EAFJ;AAGA,MAAM;AACJI,EAAAA,SADI;AAEJC,EAAAA,sBAFI;AAGJC,EAAAA,mBAHI;AAIJC,EAAAA;AAJI,IAKFL,GALJ;AAMA,MAAMM,gBAAgB,GAAG;AACvBC,EAAAA,oBAAoB,CAACC,IAAD,EAAOC,KAAP,EAAc;AAChC,QAAID,IAAI,CAACE,eAAL,MAA0BT,KAAK,CAACU,WAAN,CAAkBH,IAAI,CAACI,IAAL,CAAUC,IAA5B,CAA1B,IAA+D,CAACL,IAAI,CAACM,UAAL,CAAgBC,qBAAhB,EAApE,EAA6G;AAC3G;AACD;;AAED,QAAIP,IAAI,CAACI,IAAL,CAAUC,IAAV,KAAmB,MAAvB,EAA+B;AAC7B,UAAIG,KAAK,GAAGR,IAAI,CAACQ,KAAjB;;AAEA,SAAG;AACD,YAAIA,KAAK,CAACR,IAAN,CAAWS,UAAX,MAA2B,CAACD,KAAK,CAACR,IAAN,CAAWU,yBAAX,EAAhC,EAAwE;AACtE;AACD;AACF,OAJD,QAISF,KAAK,GAAGA,KAAK,CAACG,MAJvB;;AAMA,UAAIH,KAAJ,EAAWP,KAAK,CAACW,iBAAN,CAAwBC,IAAxB,CAA6BL,KAAK,CAACR,IAAnC;AACZ;;AAED,UAAMc,OAAO,GAAGd,IAAI,CAACQ,KAAL,CAAWO,UAAX,CAAsBf,IAAI,CAACI,IAAL,CAAUC,IAAhC,CAAhB;AACA,QAAI,CAACS,OAAL,EAAc;;AAEd,SAAK,MAAME,SAAX,IAAwBF,OAAO,CAACG,kBAAhC,EAAoD;AAClD,UAAID,SAAS,CAACR,KAAV,KAAoBM,OAAO,CAACd,IAAR,CAAaQ,KAArC,EAA4C;AAC1CP,QAAAA,KAAK,CAACiB,cAAN,GAAuB,IAAvB;AACAlB,QAAAA,IAAI,CAACmB,IAAL;AACA;AACD;AACF;;AAED,QAAIL,OAAO,KAAKb,KAAK,CAACO,KAAN,CAAYO,UAAZ,CAAuBf,IAAI,CAACI,IAAL,CAAUC,IAAjC,CAAhB,EAAwD;AACxDJ,IAAAA,KAAK,CAACmB,QAAN,CAAepB,IAAI,CAACI,IAAL,CAAUC,IAAzB,IAAiCS,OAAjC;AACD;;AA/BsB,CAAzB;;AAmCA,MAAMO,WAAN,CAAkB;AAChBC,EAAAA,WAAW,CAACtB,IAAD,EAAOQ,KAAP,EAAc;AACvB,SAAKI,iBAAL,GAAyB,KAAK,CAA9B;AACA,SAAKQ,QAAL,GAAgB,KAAK,CAArB;AACA,SAAKF,cAAL,GAAsB,KAAK,CAA3B;AACA,SAAKK,MAAL,GAAc,KAAK,CAAnB;AACA,SAAKf,KAAL,GAAa,KAAK,CAAlB;AACA,SAAKR,IAAL,GAAY,KAAK,CAAjB;AACA,SAAKwB,WAAL,GAAmB,KAAK,CAAxB;AACA,SAAKZ,iBAAL,GAAyB,EAAzB;AACA,SAAKQ,QAAL,GAAgB,EAAhB;AACA,SAAKF,cAAL,GAAsB,KAAtB;AACA,SAAKK,MAAL,GAAc,EAAd;AACA,SAAKf,KAAL,GAAaA,KAAb;AACA,SAAKR,IAAL,GAAYA,IAAZ;AACA,SAAKwB,WAAL,GAAmB,KAAnB;AACD;;AAEDC,EAAAA,iBAAiB,CAACjB,KAAD,EAAQ;AACvB,SAAK,MAAMkB,GAAX,IAAkBzC,MAAM,CAAC0C,IAAP,CAAY,KAAKP,QAAjB,CAAlB,EAA8C;AAC5C,YAAMN,OAAO,GAAG,KAAKM,QAAL,CAAcM,GAAd,CAAhB;;AAEA,UAAI,CAAClB,KAAK,CAACoB,uBAAN,CAA8BF,GAA9B,EAAmCZ,OAAO,CAACe,UAA3C,CAAL,EAA6D;AAC3D,eAAO,KAAP;AACD;AACF;;AAED,WAAO,IAAP;AACD;;AAEDC,EAAAA,mBAAmB,GAAG;AACpB,QAAItB,KAAK,GAAG,KAAKR,IAAL,CAAUQ,KAAtB;;AAEA,OAAG;AACD,UAAI,KAAKiB,iBAAL,CAAuBjB,KAAvB,CAAJ,EAAmC;AACjC,aAAKe,MAAL,CAAYV,IAAZ,CAAiBL,KAAjB;AACD,OAFD,MAEO;AACL;AACD;;AAED,UAAI,KAAKI,iBAAL,CAAuBmB,OAAvB,CAA+BvB,KAAK,CAACR,IAArC,KAA8C,CAAlD,EAAqD;AACnD;AACD;AACF,KAVD,QAUSQ,KAAK,GAAGA,KAAK,CAACG,MAVvB;AAWD;;AAEDqB,EAAAA,iBAAiB,GAAG;AAClB,QAAIhC,IAAI,GAAG,KAAKiC,kBAAL,EAAX;;AAEA,QAAI,CAACjC,IAAL,EAAW;AACX,QAAIkC,WAAW,GAAGlC,IAAI,CAACQ,KAAvB;;AAEA,QAAI0B,WAAW,CAAClC,IAAZ,KAAqBA,IAAzB,EAA+B;AAC7BkC,MAAAA,WAAW,GAAGlC,IAAI,CAACQ,KAAL,CAAWG,MAAzB;AACD;;AAED,QAAIuB,WAAW,CAAClC,IAAZ,CAAiBmC,SAAjB,MAAgCD,WAAW,CAAClC,IAAZ,CAAiBS,UAAjB,EAApC,EAAmE;AACjE,WAAK,MAAMJ,IAAX,IAAmBpB,MAAM,CAAC0C,IAAP,CAAY,KAAKP,QAAjB,CAAnB,EAA+C;AAC7C,YAAI,CAACc,WAAW,CAACE,aAAZ,CAA0B/B,IAA1B,CAAL,EAAsC;AACtC,cAAMS,OAAO,GAAG,KAAKM,QAAL,CAAcf,IAAd,CAAhB;;AAEA,YAAIS,OAAO,CAACuB,IAAR,KAAiB,OAAjB,IAA4BvB,OAAO,CAACd,IAAR,CAAasC,SAAb,KAA2B,QAA3D,EAAqE;AACnE;AACD;;AAED,cAAMC,iBAAiB,GAAG,KAAKC,0BAAL,CAAgC1B,OAAO,CAACd,IAAxC,CAA1B;;AAEA,YAAIuC,iBAAiB,CAACb,GAAlB,IAAyB1B,IAAI,CAAC0B,GAAlC,EAAuC;AACrC,eAAKF,WAAL,GAAmB,IAAnB;AACAxB,UAAAA,IAAI,GAAGc,OAAO,CAACd,IAAf;;AAEA,eAAK,MAAMyC,aAAX,IAA4B3B,OAAO,CAACG,kBAApC,EAAwD;AACtD,gBAAI,KAAKuB,0BAAL,CAAgCC,aAAhC,EAA+Cf,GAA/C,GAAqD1B,IAAI,CAAC0B,GAA9D,EAAmE;AACjE1B,cAAAA,IAAI,GAAGyC,aAAP;AACD;AACF;AACF;AACF;AACF;;AAED,WAAOzC,IAAP;AACD;;AAEDiC,EAAAA,kBAAkB,GAAG;AACnB,UAAMV,MAAM,GAAG,KAAKA,MAApB;AACA,UAAMf,KAAK,GAAGe,MAAM,CAACmB,GAAP,EAAd;AACA,QAAI,CAAClC,KAAL,EAAY;;AAEZ,QAAIA,KAAK,CAACR,IAAN,CAAWS,UAAX,EAAJ,EAA6B;AAC3B,UAAI,KAAKkC,mBAAL,CAAyBnC,KAAzB,CAAJ,EAAqC;AACnC,YAAI,KAAKA,KAAL,KAAeA,KAAnB,EAA0B;AAC1B,cAAMoC,MAAM,GAAGpC,KAAK,CAACR,IAAN,CAAW6C,GAAX,CAAe,MAAf,EAAuBA,GAAvB,CAA2B,MAA3B,CAAf;;AAEA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAACG,MAA3B,EAAmCD,CAAC,EAApC,EAAwC;AACtC,cAAIF,MAAM,CAACE,CAAD,CAAN,CAAU1C,IAAV,CAAe4C,WAAnB,EAAgC;AAChC,iBAAOJ,MAAM,CAACE,CAAD,CAAb;AACD;AACF,OARD,MAQO;AACL,eAAO,KAAKG,4BAAL,EAAP;AACD;AACF,KAZD,MAYO,IAAIzC,KAAK,CAACR,IAAN,CAAWmC,SAAX,EAAJ,EAA4B;AACjC,aAAO,KAAKc,4BAAL,EAAP;AACD;AACF;;AAEDA,EAAAA,4BAA4B,GAAG;AAC7B,UAAMzC,KAAK,GAAG,KAAKe,MAAL,CAAYmB,GAAZ,EAAd;AACA,QAAIlC,KAAJ,EAAW,OAAO,KAAKgC,0BAAL,CAAgChC,KAAK,CAACR,IAAtC,CAAP;AACZ;;AAEDwC,EAAAA,0BAA0B,CAACxC,IAAD,EAAO;AAC/B,OAAG;AACD,UAAI,CAACA,IAAI,CAACM,UAAN,IAAoB4C,KAAK,CAACC,OAAN,CAAcnD,IAAI,CAACoD,SAAnB,KAAiCpD,IAAI,CAACqD,WAAL,EAAzD,EAA6E;AAC3E,eAAOrD,IAAP;AACD;AACF,KAJD,QAISA,IAAI,GAAGA,IAAI,CAACM,UAJrB;AAKD;;AAEDqC,EAAAA,mBAAmB,CAACnC,KAAD,EAAQ;AACzB,SAAK,MAAMH,IAAX,IAAmBpB,MAAM,CAAC0C,IAAP,CAAY,KAAKP,QAAjB,CAAnB,EAA+C;AAC7C,UAAI,CAACZ,KAAK,CAAC4B,aAAN,CAAoB/B,IAApB,CAAL,EAAgC;AAChC,YAAMS,OAAO,GAAG,KAAKM,QAAL,CAAcf,IAAd,CAAhB;AACA,UAAIS,OAAO,CAACuB,IAAR,KAAiB,OAAjB,IAA4BvB,OAAO,CAACwC,QAAxC,EAAkD,OAAO,IAAP;AACnD;;AAED,WAAO,KAAP;AACD;;AAEDC,EAAAA,GAAG,GAAG;AACJ,SAAKvD,IAAL,CAAUwD,QAAV,CAAmB1D,gBAAnB,EAAqC,IAArC;AACA,QAAI,KAAKoB,cAAT,EAAyB;AACzB,SAAKY,mBAAL;AACA,UAAM2B,QAAQ,GAAG,KAAKzB,iBAAL,EAAjB;AACA,QAAI,CAACyB,QAAL,EAAe;AACf,QAAIA,QAAQ,CAACC,iBAAT,OAAiC,KAAK1D,IAAL,CAAU0D,iBAAV,EAArC,EAAoE;AACpE,QAAIC,GAAG,GAAGF,QAAQ,CAACjD,KAAT,CAAeoD,qBAAf,CAAqC,KAArC,CAAV;AACA,UAAMC,UAAU,GAAGhE,kBAAkB,CAAC8D,GAAD,EAAM,KAAK3D,IAAL,CAAUI,IAAhB,CAArC;AACA,UAAM0D,QAAQ,GAAG,KAAKtC,WAAL,GAAmB,aAAnB,GAAmC,cAApD;AACA,UAAM,CAACuC,QAAD,IAAaN,QAAQ,CAACK,QAAD,CAAR,CAAmB,CAACL,QAAQ,CAACO,oBAAT,KAAkCH,UAAlC,GAA+CjE,mBAAmB,CAAC,KAAD,EAAQ,CAACiE,UAAD,CAAR,CAAnE,CAAnB,CAAnB;AACA,UAAMlD,MAAM,GAAG,KAAKX,IAAL,CAAUM,UAAzB;;AAEA,QAAIK,MAAM,CAACsD,YAAP,MAAyB,KAAKjE,IAAL,CAAUoD,SAAV,KAAwBzC,MAAM,CAACP,IAAP,CAAY8D,QAAjE,EAA2E;AACzEP,MAAAA,GAAG,GAAGhE,sBAAsB,CAACgE,GAAD,CAA5B;AACD;;AAED,SAAK3D,IAAL,CAAUmE,WAAV,CAAsBzE,SAAS,CAACiE,GAAD,CAA/B;AACA,WAAOF,QAAQ,CAACO,oBAAT,KAAkCD,QAAQ,CAAClB,GAAT,CAAa,MAAb,CAAlC,GAAyDkB,QAAQ,CAAClB,GAAT,CAAa,qBAAb,CAAhE;AACD;;AAnJe;;AAuJlB1D,OAAO,CAACE,OAAR,GAAkBgC,WAAlB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _t = require(\"@babel/types\");\n\nvar _t2 = _t;\nconst {\n  react\n} = _t;\nconst {\n  cloneNode,\n  jsxExpressionContainer,\n  variableDeclaration,\n  variableDeclarator\n} = _t2;\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;"]},"metadata":{},"sourceType":"script"}